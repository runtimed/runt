name: PR Binary Generation

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: Pull request number to build
        required: true
        type: number
      target_os:
        description: Target operating system
        required: true
        type: choice
        options:
          - linux
          - macos
          - windows

permissions:
  contents: read
  issues: write

concurrency:
  group: pr-binary-${{ inputs.pr_number }}-${{ inputs.target_os }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
  TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

jobs:
  resolve-pr:
    name: Resolve PR metadata
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.resolve.outputs.pr_number }}
      head_sha: ${{ steps.resolve.outputs.head_sha }}
      head_short_sha: ${{ steps.resolve.outputs.head_short_sha }}
      artifact_prefix: ${{ steps.resolve.outputs.artifact_prefix }}
    steps:
      - name: Resolve pull request head commit
        id: resolve
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = Number(context.payload.inputs.pr_number);
            if (!Number.isInteger(prNumber) || prNumber <= 0) {
              core.setFailed(`Invalid PR number: ${context.payload.inputs.pr_number}`);
              return;
            }

            const { owner, repo } = context.repo;
            const { data: pr } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber,
            });

            const headSha = pr.head.sha;
            const headShortSha = headSha.slice(0, 7);
            const artifactPrefix = `nteract-pr-${prNumber}-${headShortSha}`;

            core.info(`PR #${prNumber} head commit: ${headSha}`);
            core.setOutput("pr_number", String(prNumber));
            core.setOutput("head_sha", headSha);
            core.setOutput("head_short_sha", headShortSha);
            core.setOutput("artifact_prefix", artifactPrefix);

  build:
    name: Build ${{ inputs.target_os == 'linux' && 'Linux x64' || inputs.target_os == 'macos' && 'macOS' || 'Windows x64' }} binary
    needs: [resolve-pr]
    runs-on: ${{ inputs.target_os == 'linux' && 'ubuntu-22.04' || inputs.target_os == 'macos' && 'macos-latest' || 'windows-latest' }}

    steps:
      - name: Checkout pinned PR commit
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.resolve-pr.outputs.head_sha }}
          fetch-depth: 1

      - name: Install Linux system dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev libxdo-dev \
            libssl-dev libayatana-appindicator3-dev librsvg2-dev

      - name: Install rust
        uses: dsherret/rust-toolchain-file@v1

      - uses: Swatinem/rust-cache@v2
        with:
          shared-key: pr-binary-${{ inputs.target_os }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Enable corepack
        run: corepack enable

      - name: Set pnpm store directory (Unix)
        if: runner.os != 'Windows'
        run: pnpm config set store-dir ~/.pnpm-store

      - name: Cache pnpm store (Unix)
        if: runner.os != 'Windows'
        uses: actions/cache@v4
        with:
          path: ~/.pnpm-store
          key: pnpm-store-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-store-${{ runner.os }}-

      - name: Cache pnpm store (Windows)
        if: runner.os == 'Windows'
        uses: actions/cache@v4
        with:
          path: ~\AppData\Local\pnpm\store
          key: pnpm-store-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-store-${{ runner.os }}-

      - name: Install JS dependencies
        run: pnpm install

      - name: Build frontend
        run: pnpm build

      - name: Cache tauri-cli binary (Unix)
        if: runner.os != 'Windows'
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin
          key: cargo-bin-${{ inputs.target_os }}-tauri-cli-${{ hashFiles('rust-toolchain.toml') }}
          restore-keys: |
            cargo-bin-${{ inputs.target_os }}-tauri-cli-

      - name: Cache tauri-cli binary (Windows)
        if: runner.os == 'Windows'
        uses: actions/cache@v4
        with:
          path: ~\.cargo\bin
          key: cargo-bin-${{ inputs.target_os }}-tauri-cli-${{ hashFiles('rust-toolchain.toml') }}
          restore-keys: |
            cargo-bin-${{ inputs.target_os }}-tauri-cli-

      - name: Install tauri-cli (Unix)
        if: runner.os != 'Windows'
        run: |
          if ! command -v cargo-tauri &> /dev/null; then
            cargo install tauri-cli --locked
          fi

      - name: Install tauri-cli (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          if (!(Get-Command cargo-tauri -ErrorAction SilentlyContinue)) {
            cargo install tauri-cli --locked
          }

      - name: Import Apple signing certificate
        if: runner.os == 'macOS'
        shell: bash
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          set -euo pipefail

          if [ -z "${APPLE_CERTIFICATE:-}" ]; then
            echo "::error::Missing APPLE_CERTIFICATE secret for macOS signing"
            exit 1
          fi

          if [ -z "${APPLE_CERTIFICATE_PASSWORD:-}" ]; then
            echo "::error::Missing APPLE_CERTIFICATE_PASSWORD secret for macOS signing"
            exit 1
          fi

          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "$APPLE_CERTIFICATE" | base64 --decode > "$RUNNER_TEMP/certificate.p12"
          security import "$RUNNER_TEMP/certificate.p12" \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"

          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          rm "$RUNNER_TEMP/certificate.p12"

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"

      - name: Bake PR + commit into version
        id: version
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ needs.resolve-pr.outputs.pr_number }}
          COMMIT_SHORT_SHA: ${{ needs.resolve-pr.outputs.head_short_sha }}
        with:
          script: |
            const fs = require("node:fs");

            const tauriPath = "crates/notebook/tauri.conf.json";
            const cargoPath = "crates/notebook/Cargo.toml";

            const config = JSON.parse(fs.readFileSync(tauriPath, "utf8"));
            const baseVersion = String(config.version).split("+")[0];
            const suffix = `pr.${process.env.PR_NUMBER}.sha.${process.env.COMMIT_SHORT_SHA}`;
            const version = baseVersion.includes("-")
              ? `${baseVersion}.${suffix}`
              : `${baseVersion}-${suffix}`;

            config.version = version;
            fs.writeFileSync(tauriPath, `${JSON.stringify(config, null, 2)}\n`);

            const cargoToml = fs.readFileSync(cargoPath, "utf8");
            const updatedCargoToml = cargoToml.replace(
              /^version\s*=\s*".*"$/m,
              `version = "${version}"`,
            );

            if (updatedCargoToml === cargoToml) {
              core.setFailed("Could not update notebook Cargo.toml version");
              return;
            }

            fs.writeFileSync(cargoPath, updatedCargoToml);
            core.info(`Version set to ${version}`);
            core.setOutput("version", version);

      - name: Generate icons
        run: cargo xtask icons

      - name: Build external binaries (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          cargo build --release -p runtimed -p runt-cli
          TARGET=$(rustc --print host-tuple)

          mkdir -p crates/notebook/binaries

          cp target/release/runtimed "crates/notebook/binaries/runtimed-$TARGET"
          cp target/release/runt "crates/notebook/binaries/runt-$TARGET"

      - name: Build external binaries (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          cargo build --release -p runtimed -p runt-cli
          $target = (rustc --print host-tuple).Trim()

          New-Item -ItemType Directory -Force crates/notebook/binaries | Out-Null

          Copy-Item target/release/runtimed.exe "crates/notebook/binaries/runtimed-$target.exe"
          Copy-Item target/release/runt.exe "crates/notebook/binaries/runt-$target.exe"

      - name: Build notebook app bundle (macOS signed/notarized)
        if: runner.os == 'macOS'
        uses: tauri-apps/tauri-action@v0
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          GITHUB_TOKEN: ${{ github.token }}
        with:
          projectPath: crates/notebook
          args: --bundles app,dmg --config '{"build":{"beforeBuildCommand":""}}'
          includeUpdaterJson: false

      - name: Build notebook app bundle (Linux AppImage)
        if: runner.os == 'Linux'
        working-directory: crates/notebook
        run: cargo tauri build --ci --bundles appimage --config '{"build":{"beforeBuildCommand":""}}'

      - name: Build notebook app bundle (Windows NSIS .exe)
        if: runner.os == 'Windows'
        working-directory: crates/notebook
        run: cargo tauri build --ci --bundles nsis --config '{"build":{"beforeBuildCommand":""}}'

      - name: Verify macOS bundle signature and Gatekeeper assessment
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          APP_BUNDLES=(target/release/bundle/macos/*.app)
          DMG_BINARIES=(target/release/bundle/dmg/*.dmg)
          shopt -u nullglob

          if [ ${#APP_BUNDLES[@]} -eq 0 ]; then
            echo "::error::No macOS app bundle (.app) found in target/release/bundle/macos"
            exit 1
          fi

          if [ ${#DMG_BINARIES[@]} -eq 0 ]; then
            echo "::error::No macOS installer (.dmg) found in target/release/bundle/dmg"
            exit 1
          fi

          APP_PATH="${APP_BUNDLES[0]}"
          DMG_PATH="${DMG_BINARIES[0]}"

          echo "Inspecting code signature details: $APP_PATH"
          codesign -dv --verbose=4 "$APP_PATH"

          echo "Verifying signature integrity: $APP_PATH"
          codesign --verify --deep --strict --verbose=4 "$APP_PATH"

          echo "Validating notarization ticket (app): $APP_PATH"
          xcrun stapler validate "$APP_PATH"

          echo "Validating notarization ticket (dmg): $DMG_PATH"
          xcrun stapler validate "$DMG_PATH"

          echo "Gatekeeper assessment (app): $APP_PATH"
          spctl --assess --type execute -vv "$APP_PATH"

          echo "Gatekeeper assessment (dmg): $DMG_PATH"
          set +e
          DMG_SPCTL_OUTPUT="$(spctl --assess --type open -vv "$DMG_PATH" 2>&1)"
          DMG_SPCTL_STATUS=$?
          set -e

          echo "$DMG_SPCTL_OUTPUT"

          if [ $DMG_SPCTL_STATUS -ne 0 ]; then
            if [[ "$DMG_SPCTL_OUTPUT" == *"source=Insufficient Context"* ]]; then
              echo "::warning::DMG Gatekeeper assessment returned 'Insufficient Context' in CI; notarization was validated with stapler."
            else
              exit $DMG_SPCTL_STATUS
            fi
          fi

      - name: Collect artifact payload (macOS)
        if: runner.os == 'macOS'
        shell: bash
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          mkdir -p pr-binary
          shopt -s nullglob
          APP_BUNDLES=(target/release/bundle/macos/*.app)
          DMG_BINARIES=(target/release/bundle/dmg/*.dmg)
          TAR_GZ_BINARIES=(target/release/bundle/macos/*.tar.gz)
          TAR_GZ_SIG_BINARIES=(target/release/bundle/macos/*.tar.gz.sig)
          shopt -u nullglob

          if [ ${#APP_BUNDLES[@]} -eq 0 ]; then
            echo "::error::No macOS app bundle (.app) found in target/release/bundle/macos"
            exit 1
          fi

          if [ ${#DMG_BINARIES[@]} -eq 0 ]; then
            echo "::error::No macOS installer (.dmg) found in target/release/bundle/dmg"
            exit 1
          fi

          cp -R "${APP_BUNDLES[0]}" pr-binary/nteract.app
          cp "${DMG_BINARIES[0]}" pr-binary/nteract-macos.dmg
          if [ ${#TAR_GZ_BINARIES[@]} -gt 0 ]; then
            cp "${TAR_GZ_BINARIES[0]}" pr-binary/nteract-macos.app.tar.gz
          fi
          if [ ${#TAR_GZ_SIG_BINARIES[@]} -gt 0 ]; then
            cp "${TAR_GZ_SIG_BINARIES[0]}" pr-binary/nteract-macos.app.tar.gz.sig
          fi

          cat > pr-binary/build-metadata.json <<EOF
          {
            "pr_number": "${{ needs.resolve-pr.outputs.pr_number }}",
            "target_os": "${{ inputs.target_os }}",
            "commit": "${{ needs.resolve-pr.outputs.head_sha }}",
            "version": "$VERSION",
            "bundle": "app+dmg"
          }
          EOF

      - name: Collect artifact payload (Linux)
        if: runner.os == 'Linux'
        shell: bash
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          mkdir -p pr-binary
          shopt -s nullglob
          APPIMAGE_BINARIES=(target/release/bundle/appimage/*.AppImage)
          shopt -u nullglob

          if [ ${#APPIMAGE_BINARIES[@]} -eq 0 ]; then
            echo "::error::No Linux AppImage found in target/release/bundle/appimage"
            exit 1
          fi

          APPIMAGE_PATH="${APPIMAGE_BINARIES[0]}"
          cp "$APPIMAGE_PATH" pr-binary/notebook-linux-x64.AppImage
          chmod +x pr-binary/notebook-linux-x64.AppImage

          APPIMAGE_SIG_PATH="${APPIMAGE_PATH}.sig"
          if [ -f "$APPIMAGE_SIG_PATH" ]; then
            cp "$APPIMAGE_SIG_PATH" pr-binary/notebook-linux-x64.AppImage.sig
          fi

          cat > pr-binary/build-metadata.json <<EOF
          {
            "pr_number": "${{ needs.resolve-pr.outputs.pr_number }}",
            "target_os": "${{ inputs.target_os }}",
            "commit": "${{ needs.resolve-pr.outputs.head_sha }}",
            "version": "$VERSION",
            "bundle": "appimage"
          }
          EOF

      - name: Collect artifact payload (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          New-Item -ItemType Directory -Force pr-binary | Out-Null
          $nsisBinaries = Get-ChildItem -Path target/release/bundle/nsis -Filter *.exe -File
          if ($nsisBinaries.Count -eq 0) {
            Write-Error "No Windows NSIS installer (.exe) found in target/release/bundle/nsis"
            exit 1
          }

          $nsisPath = $nsisBinaries[0].FullName
          Copy-Item $nsisPath pr-binary/notebook-windows-x64.exe

          $nsisSigPath = "$nsisPath.sig"
          if (Test-Path $nsisSigPath) {
            Copy-Item $nsisSigPath pr-binary/notebook-windows-x64.exe.sig
          }

          $metadata = @{
            pr_number = "${{ needs.resolve-pr.outputs.pr_number }}"
            target_os = "${{ inputs.target_os }}"
            commit = "${{ needs.resolve-pr.outputs.head_sha }}"
            version = "$env:VERSION"
            bundle = "nsis"
          } | ConvertTo-Json

          Set-Content -Path pr-binary/build-metadata.json -Value $metadata

      - name: Upload runnable binary artifact
        id: upload-artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ needs.resolve-pr.outputs.artifact_prefix }}-${{ inputs.target_os == 'linux' && 'linux-x64' || inputs.target_os == 'macos' && 'macos' || 'windows-x64' }}
          path: pr-binary/
          retention-days: 14

      - name: Comment on PR with artifact link
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ needs.resolve-pr.outputs.pr_number }}
          TARGET_OS: ${{ inputs.target_os }}
          COMMIT_SHORT_SHA: ${{ needs.resolve-pr.outputs.head_short_sha }}
          VERSION: ${{ steps.version.outputs.version }}
          ARTIFACT_NAME: ${{ needs.resolve-pr.outputs.artifact_prefix }}-${{ inputs.target_os == 'linux' && 'linux-x64' || inputs.target_os == 'macos' && 'macos' || 'windows-x64' }}
          ARTIFACT_URL: ${{ steps.upload-artifact.outputs.artifact-url }}
          ARTIFACT_ID: ${{ steps.upload-artifact.outputs.artifact-id }}
        run: |
          set -euo pipefail

          if [[ ! "$PR_NUMBER" =~ ^[1-9][0-9]*$ ]]; then
            echo "::error::Invalid PR number: $PR_NUMBER"
            exit 1
          fi

          REPO="$GITHUB_REPOSITORY"
          RUN_URL="https://github.com/${REPO}/actions/runs/${GITHUB_RUN_ID}"
          ARTIFACT_URL_FROM_ACTION="${ARTIFACT_URL:-}"
          ARTIFACT_ID_TRIMMED="${ARTIFACT_ID:-}"

          if [ -n "$ARTIFACT_URL_FROM_ACTION" ]; then
            ARTIFACT_LINK="$ARTIFACT_URL_FROM_ACTION"
          elif [ -n "$ARTIFACT_ID_TRIMMED" ]; then
            ARTIFACT_LINK="https://github.com/${REPO}/actions/runs/${GITHUB_RUN_ID}/artifacts/${ARTIFACT_ID_TRIMMED}"
          else
            ARTIFACT_LINK="$RUN_URL"
          fi

          MARKER="<!-- pr-binary-artifact:${TARGET_OS} -->"
          export MARKER RUN_URL ARTIFACT_LINK

          BODY="$(
            node -e '
              const marker = process.env.MARKER;
              const targetOs = process.env.TARGET_OS;
              const version = process.env.VERSION;
              const commit = process.env.COMMIT_SHORT_SHA;
              const artifactName = process.env.ARTIFACT_NAME;
              const artifactLink = process.env.ARTIFACT_LINK;
              const runUrl = process.env.RUN_URL;
              console.log(
                [
                  marker,
                  "âœ… PR binary artifact is ready.",
                  "",
                  `- **OS:** \`${targetOs}\``,
                  `- **Version:** \`${version}\``,
                  `- **Commit:** \`${commit}\``,
                  `- **Artifact:** [${artifactName}](${artifactLink})`,
                  `- **Workflow run:** [View run](${runUrl})`,
                  "",
                  "Download requires GitHub authentication and is available for 14 days.",
                ].join("\n"),
              );
            '
          )"

          gh_api_with_permission_fallback() {
            local output
            local status

            set +e
            output="$(gh api "$@" 2>&1)"
            status=$?
            set -e

            if [ $status -ne 0 ]; then
              if [[ "$output" == *"Resource not accessible by integration"* ]]; then
                echo "::warning::Skipping PR artifact comment for PR #${PR_NUMBER} because token lacks issue comment permissions." >&2
                echo "Artifact URL: $ARTIFACT_LINK" >&2
                echo "Workflow run URL: $RUN_URL" >&2
                return 100
              fi

              echo "$output" >&2
              return $status
            fi

            printf '%s' "$output"
          }

          COMMENTS_JSON="$(gh_api_with_permission_fallback "repos/${REPO}/issues/${PR_NUMBER}/comments?per_page=100")" || {
            status=$?
            if [ $status -eq 100 ]; then
              exit 0
            fi
            exit $status
          }

          EXISTING_COMMENT_ID="$(
            printf '%s' "$COMMENTS_JSON" | node -e '
              const fs = require("node:fs");
              const marker = process.env.MARKER;
              const comments = JSON.parse(fs.readFileSync(0, "utf8"));
              const existing = comments.find(
                (comment) =>
                  comment.user?.type === "Bot" && (comment.body || "").includes(marker),
              );
              if (existing) {
                process.stdout.write(String(existing.id));
              }
            '
          )"

          if [ -n "$EXISTING_COMMENT_ID" ]; then
            gh_api_with_permission_fallback \
              -X PATCH \
              "repos/${REPO}/issues/comments/${EXISTING_COMMENT_ID}" \
              -f body="$BODY" >/dev/null || {
              status=$?
              if [ $status -eq 100 ]; then
                exit 0
              fi
              exit $status
            }
            echo "Updated existing artifact comment for PR #${PR_NUMBER} (${TARGET_OS})"
          else
            gh_api_with_permission_fallback \
              -X POST \
              "repos/${REPO}/issues/${PR_NUMBER}/comments" \
              -f body="$BODY" >/dev/null || {
              status=$?
              if [ $status -eq 100 ]; then
                exit 0
              fi
              exit $status
            }
            echo "Posted artifact comment for PR #${PR_NUMBER} (${TARGET_OS})"
          fi

      - name: Cleanup Apple signing keychain
        if: always() && runner.os == 'macOS'
        shell: bash
        run: |
          if [ -n "${KEYCHAIN_PATH:-}" ] && [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi
